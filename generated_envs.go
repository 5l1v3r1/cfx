// Code generated by renum v0.0.9-92309cb (github.com/gen0cide/renum) DO NOT EDIT.

package cfx

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

// Env is a generated type alias for the Env enum.
// Env defines the a possible environment the app can be running in.
type Env int

const (
	// EnvUndefinedEnumValue is an enum value for type Env.
	// EnvUndefinedEnumValue is the default value for enum type Env. It is meant to be a place holder and default for unknown values.
	EnvUndefinedEnumValue Env = iota

	// EnvDevelopment is an enum value for type Env.
	// Development is a specific environment for development purposes.
	// Development is a specific environment for development purposes.
	EnvDevelopment

	// EnvTest is an enum value for type Env.
	// Test is a specific environment for testing purposes.
	// Test is a specific environment for testing purposes.
	EnvTest

	// EnvStaging is an enum value for type Env.
	// Staging is a specific environment for staging purposes.
	// Staging is a specific environment for staging purposes.
	EnvStaging

	// EnvProduction is an enum value for type Env.
	// Production is a specific environment for production purposes.
	// Production is a specific environment for production purposes.
	EnvProduction
)

var (
	// ErrUndefinedEnvEnumValue is thrown when ParseEnv(s string) cannot locate a valid enum for the provided string.
	ErrUndefinedEnvEnumValue = errors.New("cannot identify enum for provided value")
)

// ParseEnv attempts to convert a string identifier to it's corrasponding Env value, returning
// an error if it cannot match the string to a known enum value. This function supports multiple casings including:
// snake_case, PascalCase, camelCase, SCREAMING_CASE, and command-case. Generally, snake_case is the preferred method
// as most Marshalers will marshal to snake_case, and this function optimizes for it, but ParseEnv attempts to
// be flexible.
//
// In the event ParseEnv cannot identify a matching value, it will return the default Env value (0)
// along with an ErrUndefinedEnvEnumValue error. This will also be the return should you provide either an empty
// string or a string that doesn't contain a valid UTF-8 alpha character as the first rune in the string. There are
// two exceptions to this rule:
//
//  * The string has leading is whitespace in which case ParseEnv will detect, trim, and attempt to parse the result.
//  * The string is an integer, in which case it will attempt to match the Env value for that corrasponding integer.
//
// If either of those options cannot subsequently locate a corrasponding enum value, it will return the default error
// behavior described above.
func ParseEnv(name string) (Env, error) {
	if len(name) < 1 {
		return Env(0), ErrUndefinedEnvEnumValue
	}

	first, _ := utf8.DecodeRuneInString(name)
	if first == utf8.RuneError {
		return Env(0), ErrUndefinedEnvEnumValue
	}

	switch {
	case unicode.IsLower(first):
		// test for snake_case
		if x, ok := _EnvValue[name]; ok {
			return x, nil
		}
		// test for command-case
		if x, ok := _EnvCommandValue[name]; ok {
			return x, nil
		}
		// test for camelCase
		if x, ok := _EnvCamelValue[name]; ok {
			return x, nil
		}
		// test for dotted.case
		if x, ok := _EnvDottedValue[name]; ok {
			return x, nil
		}
	case unicode.IsUpper(first):
		// test for PascalCase
		if x, ok := _EnvPascalValue[name]; ok {
			return x, nil
		}
		// test for SCREAMING_CASE
		if x, ok := _EnvScreamingValue[name]; ok {
			return x, nil
		}

		// test for SCREAMING_CASE
		if x, ok := _EnvTrainValue[name]; ok {
			return x, nil
		}
	case unicode.IsSpace(first):
		// the provided string had whitespace. Trim it and try again.
		return ParseEnv(strings.TrimSpace(name))
	case unicode.IsDigit(first):
		// the provided string started with a number - assuming this is
		// an integer and attempting to match it to a value.
		intVal, err := strconv.Atoi(name)
		if err != nil {
			return Env(0), ErrUndefinedEnvEnumValue
		}

		// use the Coder interface Lookup function to identify the integer value (if it exists).
		return LookupEnv(intVal)
	default:
		return Env(0), ErrUndefinedEnvEnumValue
	}

	return Env(0), ErrUndefinedEnvEnumValue
}

// LookupEnv attempts to convert a int to it's equivelent Env value.
func LookupEnv(id int) (Env, error) {
	if _, ok := _EnvMap[Env(id)]; ok {
		return Env(id), nil
	}

	return Env(0), ErrUndefinedEnvEnumValue
}

// Code implements the renum.Coder interface and allows an enum value to self report it's underlying integer ID. This
// primarily was intended to be able to support generic numeric types, but at this time, it's simply an int.
// This method implements the github.com/gen0cide/renum.Coder interface.
func (x Env) Code() int {
	return int(x)
}

const _EnvName = _EnvSnakeName

var _EnvValue = _EnvSnakeValue

var _EnvMap = _EnvSnakeMap

// String implements the Stringer interface.
func (x Env) String() string {
	if str, ok := _EnvMap[x]; ok {
		return str
	}

	return _EnvMap[Env(0)]
}

const _EnvSnakeName = "undefined_enum_valuedevelopmentteststagingproduction"

var _EnvSnakeValue = map[string]Env{
	_EnvSnakeName[0:20]:  0,
	_EnvSnakeName[20:31]: 1,
	_EnvSnakeName[31:35]: 2,
	_EnvSnakeName[35:42]: 3,
	_EnvSnakeName[42:52]: 4,
}

var _EnvSnakeMap = map[Env]string{
	0: _EnvSnakeName[0:20],
	1: _EnvSnakeName[20:31],
	2: _EnvSnakeName[31:35],
	3: _EnvSnakeName[35:42],
	4: _EnvSnakeName[42:52],
}

// SnakeCase returns the enum as a snake_case string.
func (x Env) SnakeCase() string {
	if str, ok := _EnvMap[x]; ok {
		return str
	}

	return _EnvMap[Env(0)]
}

const _EnvCommandName = "undefined-enum-valuedevelopmentteststagingproduction"

var _EnvCommandValue = map[string]Env{
	_EnvCommandName[0:20]:  0,
	_EnvCommandName[20:31]: 1,
	_EnvCommandName[31:35]: 2,
	_EnvCommandName[35:42]: 3,
	_EnvCommandName[42:52]: 4,
}

var _EnvCommandMap = map[Env]string{
	0: _EnvCommandName[0:20],
	1: _EnvCommandName[20:31],
	2: _EnvCommandName[31:35],
	3: _EnvCommandName[35:42],
	4: _EnvCommandName[42:52],
}

// CommandCase returns the enum as a command-case string.
func (x Env) CommandCase() string {
	if str, ok := _EnvCommandMap[x]; ok {
		return str
	}

	return _EnvCommandMap[Env(0)]
}

const _EnvScreamingName = "UNDEFINED_ENUM_VALUEDEVELOPMENTTESTSTAGINGPRODUCTION"

var _EnvScreamingValue = map[string]Env{
	_EnvScreamingName[0:20]:  0,
	_EnvScreamingName[20:31]: 1,
	_EnvScreamingName[31:35]: 2,
	_EnvScreamingName[35:42]: 3,
	_EnvScreamingName[42:52]: 4,
}

var _EnvScreamingMap = map[Env]string{
	0: _EnvScreamingName[0:20],
	1: _EnvScreamingName[20:31],
	2: _EnvScreamingName[31:35],
	3: _EnvScreamingName[35:42],
	4: _EnvScreamingName[42:52],
}

// ScreamingCase returns the enum as a SCREAMING_CASE string.
func (x Env) ScreamingCase() string {
	if str, ok := _EnvScreamingMap[x]; ok {
		return str
	}

	return _EnvScreamingMap[Env(0)]
}

// Type implements the renum.Typer interface and allows the Env to self report the type of value it is.
// This method implements the github.com/gen0cide/renum.Typer interface.
func (x Env) Type() string {
	return "Env"
}

const _EnvPascalName = "UndefinedEnumValueDevelopmentTestStagingProduction"

var _EnvPascalValue = map[string]Env{
	_EnvPascalName[0:18]:  0,
	_EnvPascalName[18:29]: 1,
	_EnvPascalName[29:33]: 2,
	_EnvPascalName[33:40]: 3,
	_EnvPascalName[40:50]: 4,
}

var _EnvPascalMap = map[Env]string{
	0: _EnvPascalName[0:18],
	1: _EnvPascalName[18:29],
	2: _EnvPascalName[29:33],
	3: _EnvPascalName[33:40],
	4: _EnvPascalName[40:50],
}

// PascalCase returns the enum as a PascalCase string.
func (x Env) PascalCase() string {
	if str, ok := _EnvPascalMap[x]; ok {
		return str
	}

	return _EnvPascalMap[Env(0)]
}

const _EnvCamelName = "undefinedEnumValuedevelopmentteststagingproduction"

var _EnvCamelValue = map[string]Env{
	_EnvCamelName[0:18]:  0,
	_EnvCamelName[18:29]: 1,
	_EnvCamelName[29:33]: 2,
	_EnvCamelName[33:40]: 3,
	_EnvCamelName[40:50]: 4,
}

var _EnvCamelMap = map[Env]string{
	0: _EnvCamelName[0:18],
	1: _EnvCamelName[18:29],
	2: _EnvCamelName[29:33],
	3: _EnvCamelName[33:40],
	4: _EnvCamelName[40:50],
}

// CamelCase returns the enum value as a camelCase string.
func (x Env) CamelCase() string {
	if str, ok := _EnvCamelMap[x]; ok {
		return str
	}

	return _EnvCamelMap[Env(0)]
}

const _EnvDottedName = "undefined.enum.valuedevelopmentteststagingproduction"

var _EnvDottedValue = map[string]Env{
	_EnvDottedName[0:20]:  0,
	_EnvDottedName[20:31]: 1,
	_EnvDottedName[31:35]: 2,
	_EnvDottedName[35:42]: 3,
	_EnvDottedName[42:52]: 4,
}

var _EnvDottedMap = map[Env]string{
	0: _EnvDottedName[0:20],
	1: _EnvDottedName[20:31],
	2: _EnvDottedName[31:35],
	3: _EnvDottedName[35:42],
	4: _EnvDottedName[42:52],
}

// DottedCase returns the enum value as a dotted.case string.
func (x Env) DottedCase() string {
	if str, ok := _EnvDottedMap[x]; ok {
		return str
	}

	return _EnvDottedMap[Env(0)]
}

const _EnvTrainName = "UNDEFINED-ENUM-VALUEDEVELOPMENTTESTSTAGINGPRODUCTION"

var _EnvTrainValue = map[string]Env{
	_EnvTrainName[0:20]:  0,
	_EnvTrainName[20:31]: 1,
	_EnvTrainName[31:35]: 2,
	_EnvTrainName[35:42]: 3,
	_EnvTrainName[42:52]: 4,
}

var _EnvTrainMap = map[Env]string{
	0: _EnvTrainName[0:20],
	1: _EnvTrainName[20:31],
	2: _EnvTrainName[31:35],
	3: _EnvTrainName[35:42],
	4: _EnvTrainName[42:52],
}

// TrainCase returns the enum value as a TRAIN-CASE string.
func (x Env) TrainCase() string {
	if str, ok := _EnvTrainMap[x]; ok {
		return str
	}

	return _EnvTrainMap[Env(0)]
}

const (
	_EnvPkgName = `cfx`
	_EnvPkgPath = `github.com/gen0cide/cfx`
)

// PackageName returns the name of the parent package for the Env type as
// part of the github.com/gen0cide/renum.Sourcer interface.
func (x Env) PackageName() string {
	return _EnvPkgName
}

// ImportPath returns the full import path of the parent package for the Env
// type as part of the github.com/gen0cide/renum.Sourcer interface.
func (x Env) PackagePath() string {
	return _EnvPkgPath
}

var _EnvExportRefs = map[Env]string{
	0: `github.com/gen0cide/cfx.EnvUndefinedEnumValue`,
	1: `github.com/gen0cide/cfx.EnvDevelopment`,
	2: `github.com/gen0cide/cfx.EnvTest`,
	3: `github.com/gen0cide/cfx.EnvStaging`,
	4: `github.com/gen0cide/cfx.EnvProduction`,
}

// ExportRef returns the full Go import path for the parent package of Env
// joined with the exported name for the enum value. This is part of the github.com/gen0cide/renum.Sourcer interface.
func (x Env) ExportRef() string {
	if str, ok := _EnvExportRefs[x]; ok {
		return str
	}

	return _EnvExportRefs[Env(0)]
}

var _EnvExportTypes = map[Env]string{
	0: `cfx.EnvUndefinedEnumValue`,
	1: `cfx.EnvDevelopment`,
	2: `cfx.EnvTest`,
	3: `cfx.EnvStaging`,
	4: `cfx.EnvProduction`,
}

// ExportType returns package name the parent package of Env joined with the
// exported name for the enum value. This is part of the github.com/gen0cide/renum.Sourcer interface.
func (x Env) ExportType() string {
	if str, ok := _EnvExportTypes[x]; ok {
		return str
	}

	return _EnvExportTypes[Env(0)]
}

var _EnvValueSlice = []Env{
	EnvUndefinedEnumValue,
	EnvDevelopment,
	EnvTest,
	EnvStaging,
	EnvProduction,
}

// EnvValues returns a list of possible enum values for the Env type.
func EnvValues() []Env {
	tmp := make([]Env, len(_EnvValueSlice))
	copy(tmp, _EnvValueSlice)
	return tmp
}

var _EnvNames = []string{
	_EnvSnakeName[0:20],
	_EnvSnakeName[20:31],
	_EnvSnakeName[31:35],
	_EnvSnakeName[35:42],
	_EnvSnakeName[42:52],
}

// EnvNames returns a list of possible string values of Env.
func EnvNames() []string {
	tmp := make([]string, len(_EnvNames))
	copy(tmp, _EnvNames)
	return tmp
}

var _EnvDescriptions = map[Env]string{
	0: `EnvUndefinedEnumValue is the default value for enum type Env. It is meant to be a place holder and default for unknown values.`,
	1: `Development is a specific environment for development purposes.`,
	2: `Test is a specific environment for testing purposes.`,
	3: `Staging is a specific environment for staging purposes.`,
	4: `Production is a specific environment for production purposes.`,
}

// Description allows a caller to retrieve more detailed description information
// about an enum value. This information is not passed around with the enum, but kept
// inside the source package and retrieved with this method. This method implements
// the github.com/gen0cide/renum.Descriptioner interface.
func (x Env) Description() string {
	if str, ok := _EnvDescriptions[x]; ok {
		return str
	}

	return _EnvDescriptions[Env(0)]
}

const (
	_EnvNamespace = `github.com.gen0cide.cfx`
)

// Namespace returns the a dotted namespace representation of the Go package import
// path for the parent package to Env. This method implements the github.com/gen0cide/renum.Namespacer interface.
func (x Env) Namespace() string {
	return _EnvNamespace
}

var _EnvPaths = map[Env]string{
	0: `github.com.gen0cide.cfx.env_undefined_enum_value`,
	1: `github.com.gen0cide.cfx.env_development`,
	2: `github.com.gen0cide.cfx.env_test`,
	3: `github.com.gen0cide.cfx.env_staging`,
	4: `github.com.gen0cide.cfx.env_production`,
}

// Paths returns a full "path" comprised of namespace + id for a given enum value. This
// method implements the github.com/gen0cide/renum.Namespacer interface.
func (x Env) Path() string {
	if str, ok := _EnvPaths[x]; ok {
		return str
	}

	return _EnvPaths[Env(0)]
}

var _EnvIDs = map[Env]string{
	0: `env_undefined_enum_value`,
	1: `env_development`,
	2: `env_test`,
	3: `env_staging`,
	4: `env_production`,
}

// ID returns a snake_case identifier comprised of the enum's standard snake_case prefixed
// with the Env's snake_case name. This method implements the github.com/gen0cide/renum.Namespacer interface.
func (x Env) ID() string {
	if str, ok := _EnvIDs[x]; ok {
		return str
	}

	return _EnvIDs[Env(0)]
}

// Name returns a snake case identifier comprised of the enum's actual identifier. This name essentially is an alias
// to the String() function.
func (x Env) Name() string {
	return x.String()
}

// MarshalText implements the encoding.TextMarshaler interface and allows Env values
// to be encoded to text, supporting any format that uses encoding.TextMarshaler under the hood.
func (x Env) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface and allows Env values
// to be decoded from anything using this generic interface.
func (x *Env) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseEnv(name)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalJSON implements the json.Marshaler interface.
func (x Env) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *Env) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return fmt.Errorf("error unmarshaling JSON value: %v", err)
	}

	tmp, err := ParseEnv(s)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalCSV implements the csvutil.Marshaler interface. (https://godoc.org/github.com/jszwec/csvutil#Marshaler)
func (x Env) MarshalCSV() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalCSV implements the csvutil.Unmarshaler interface. (https://godoc.org/github.com/jszwec/csvutil#Unmarshaler)
func (x *Env) UnmarshalCSV(b []byte) error {
	tmp, err := ParseEnv(string(b))
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// MarshalYAML implements the yaml.Marshaler interface.
func (x Env) MarshalYAML() (interface{}, error) {
	return x.String(), nil
}

// UnmarshalYAML implements the yaml.Unmarshaler interface.
func (x *Env) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return fmt.Errorf("error unmarshaling YAML value: %v", err)
	}

	tmp, err := ParseEnv(s)
	if err != nil {
		return err
	}

	*x = tmp
	return nil
}

// Scan implements the sql.Scanner interface and allows for translating database results into Env values.
// This does a best effort to match whatever might be returned (integer values, strings, or bytes) into a matching
// value, and follows the semantics of ParseEnv.
func (x *Env) Scan(value interface{}) error {
	var name string

	// handle the various types for the value that could be provided to us
	switch v := value.(type) {
	case string:
		name = v
	case []byte:
		name = string(v)
	case int8:
		name = strconv.FormatInt(int64(v), 10)
	case int16:
		name = strconv.FormatInt(int64(v), 10)
	case int32:
		name = strconv.FormatInt(int64(v), 10)
	case int:
		name = strconv.FormatInt(int64(v), 10)
	case int64:
		name = strconv.FormatInt(v, 10)
	case uint8:
		name = strconv.FormatUint(uint64(v), 10)
	case uint16:
		name = strconv.FormatUint(uint64(v), 10)
	case uint32:
		name = strconv.FormatUint(uint64(v), 10)
	case uint64:
		name = strconv.FormatUint(v, 10)
	case uint:
		name = strconv.FormatUint(uint64(v), 10)
	case nil:
		*x = Env(0)
		return nil
	case fmt.Stringer:
		name = v.String()
	default:
		return ErrUndefinedEnvEnumValue
	}

	// try and lookup the the value
	tmp, err := ParseEnv(name)
	if err != nil {
		return err
	}

	// assign it to ourselves
	*x = tmp
	return nil
}

// Value implements the driver.Valuer interface to enable automatic conversion of renum.Enum values into
// database types. By default, this is done with as a snake_case string to support as many database
// implementations as possible. If you wish to optimize to integers or other types, implement a wrapper type.
func (x Env) Value() (driver.Value, error) {
	return x.String(), nil
}

// Set implements the Golang flag.Value interface and allows command line flags that are bound to Env types
// to automatically support string representations for value assignment. This follows the semantics of ParseEnv
// and thus can be flexible for how the string should be cased, etc. If an appropriate value cannot be identified,
// it will return an error.
func (x *Env) Set(val string) error {
	v, err := ParseEnv(val)
	if err != nil {
		return err
	}

	// all good, set the value!
	*x = v
	return nil
}

// Get implements the Golang flag.Getter interface and allows for the value of flag.Value to be retrieved
// by the flag package for various reasons.
func (x *Env) Get() interface{} {
	if x == nil {
		return nil
	}

	return *x
}
